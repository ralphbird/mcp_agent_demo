"""Prometheus metrics middleware for load tester."""

import time
from collections.abc import Callable

from fastapi import Request, Response
from prometheus_client import Counter, Gauge, Histogram, generate_latest
from starlette.middleware.base import BaseHTTPMiddleware

# Load Tester API Metrics
load_tester_http_requests_total = Counter(
    "load_tester_http_requests_total",
    "Total number of HTTP requests to load tester API",
    ["method", "endpoint", "status_code"],
)

load_tester_http_request_duration_seconds = Histogram(
    "load_tester_http_request_duration_seconds",
    "HTTP request duration in seconds for load tester API",
    ["method", "endpoint"],
)

load_tester_http_requests_in_progress = Gauge(
    "load_tester_http_requests_in_progress",
    "Number of HTTP requests currently being processed by load tester API",
)

# Load Test Execution Metrics
load_test_active = Gauge(
    "load_test_active",
    "Whether a load test is currently active (1 = active, 0 = inactive)",
)

load_test_requests_per_second_configured = Gauge(
    "load_test_requests_per_second_configured",
    "Configured requests per second for current load test",
)

load_test_requests_total = Counter(
    "load_test_requests_total",
    "Total number of requests generated by load test",
    ["target_endpoint", "success"],
)

load_test_request_duration_seconds = Histogram(
    "load_test_request_duration_seconds",
    "Request duration in seconds for load test requests",
    ["target_endpoint"],
)

load_test_currency_pairs_total = Counter(
    "load_test_currency_pairs_total",
    "Total number of currency conversion requests by pair",
    ["from_currency", "to_currency"],
)


class LoadTesterPrometheusMiddleware(BaseHTTPMiddleware):
    """Middleware to collect Prometheus metrics for load tester API."""

    async def dispatch(self, request: Request, call_next: Callable) -> Response:
        """Process request and collect metrics."""
        # Skip metrics endpoint to avoid recursive tracking
        if request.url.path == "/metrics":
            return await call_next(request)

        # Track request in progress
        load_tester_http_requests_in_progress.inc()

        start_time = time.time()
        endpoint_pattern = self._get_endpoint_pattern(request)

        try:
            response = await call_next(request)
            status_code = str(response.status_code)
        except Exception as e:
            status_code = "500"
            # Re-raise the exception after metrics collection
            raise e
        finally:
            # Record metrics
            duration = time.time() - start_time

            load_tester_http_requests_total.labels(
                method=request.method,
                endpoint=endpoint_pattern,
                status_code=status_code,
            ).inc()

            load_tester_http_request_duration_seconds.labels(
                method=request.method,
                endpoint=endpoint_pattern,
            ).observe(duration)

            load_tester_http_requests_in_progress.dec()

        return response

    def _get_endpoint_pattern(self, request: Request) -> str:
        """Get normalized endpoint pattern for metrics.

        Args:
            request: HTTP request

        Returns:
            Normalized endpoint pattern
        """
        path = request.url.path

        # Map specific endpoints to patterns
        if path.startswith("/api/load-test"):
            if path.endswith("/start"):
                return "/api/load-test/start"
            if path.endswith("/stop"):
                return "/api/load-test/stop"
            if path.endswith("/status"):
                return "/api/load-test/status"
            return "/api/load-test/{action}"
        if path == "/":
            return "/"
        if path == "/docs" or path.startswith("/docs"):
            return "/docs"
        return path


def record_load_test_start(requests_per_second: float) -> None:
    """Record that a load test has started.

    Args:
        requests_per_second: Configured requests per second
    """
    load_test_active.set(1)
    load_test_requests_per_second_configured.set(requests_per_second)


def record_load_test_stop() -> None:
    """Record that a load test has stopped."""
    load_test_active.set(0)
    load_test_requests_per_second_configured.set(0)


def record_load_test_request(
    target_endpoint: str,
    *,
    success: bool,
    duration_seconds: float,
    from_currency: str | None = None,
    to_currency: str | None = None,
) -> None:
    """Record a load test request.

    Args:
        target_endpoint: The endpoint being tested
        success: Whether the request was successful
        duration_seconds: Request duration in seconds
        from_currency: Source currency (for currency conversion requests)
        to_currency: Target currency (for currency conversion requests)
    """
    success_label = "true" if success else "false"

    load_test_requests_total.labels(
        target_endpoint=target_endpoint,
        success=success_label,
    ).inc()

    load_test_request_duration_seconds.labels(
        target_endpoint=target_endpoint,
    ).observe(duration_seconds)

    # Record currency pair metrics for conversion requests
    if from_currency and to_currency:
        load_test_currency_pairs_total.labels(
            from_currency=from_currency,
            to_currency=to_currency,
        ).inc()


def get_load_tester_metrics() -> str:
    """Get Prometheus metrics in text format.

    Returns:
        Metrics in Prometheus text format
    """
    return generate_latest().decode("utf-8")
