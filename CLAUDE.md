# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a comprehensive orchestration system for currency conversion services, designed to demonstrate
advanced monitoring, observability, and containerization practices. The system includes:

- **External Currency API**: Deploys FastAPI currency service from external GitHub repository
- **Interactive Dashboard**: Streamlit web interface for conversions and analytics
- **Load Testing Service**: Built-in performance testing with configurable scenarios
- **Full Observability Stack**: Prometheus metrics, Grafana dashboards, and Jaeger tracing
- **Production Docker Deployment**: Complete containerized setup with monitoring

## Development Commands (Docker-First)

### Quick Start

```bash
make              # Show help with available commands (default)
make up           # Start all services with full monitoring stack
make down         # Stop all services
make logs         # View service logs (Ctrl+C to exit)
```

### Docker Workflow

```bash
make rebuild                   # Rebuild containers and restart all services
make clean                     # Clean all Docker resources (images, volumes, containers)
make test                      # Run tests with coverage inside container
make quality                   # Run code quality checks (format, lint, type-check)
```

### Local Development (Alternative)

```bash
poetry install                                    # Install dependencies
# Currency API is deployed from external repository via Docker
poetry run streamlit run dashboard/app.py         # Start dashboard (separate terminal)
```

### Testing Commands

```bash
make test                                         # Full test suite with coverage (Docker)
poetry run pytest tests/ -v --cov=load_tester --cov=dashboard --cov-report=term-missing
poetry run pytest tests/load_tester/test_load_generator.py -v  # Run specific test file
poetry run pytest tests/dashboard/ -v                              # Run dashboard tests
poetry run pytest -k "test_convert" -v           # Run tests matching pattern
```

### Code Quality

```bash
make quality                                      # All quality checks (Docker)
poetry run ruff format load_tester/ dashboard/ tests/  # Format code
poetry run ruff check --fix load_tester/ dashboard/ tests/        # Lint code
poetry run pyright load_tester/ dashboard/ tests/            # Type checking
# OpenAPI spec generated by external currency API repository
```

## Architecture Overview

### Application Structure

```text
currency_app/
├── main.py              # FastAPI app with lifespan, middleware, and tracing setup
├── config.py            # Pydantic Settings for environment-based configuration
├── database.py          # SQLAlchemy engine, session management
├── tracing_config.py    # OpenTelemetry tracing configuration
├── logging_config.py    # Structured logging setup
├── routers/             # FastAPI route handlers
│   ├── conversion.py    # Currency conversion endpoints
│   ├── rates.py         # Current + historical rates endpoints
│   ├── health.py        # Health check endpoints
│   └── home.py          # API information endpoint
├── services/            # Business logic layer
│   ├── currency_service.py        # Core conversion logic with simulated rates
│   └── rates_history_service.py   # Historical data management
├── models/              # Data models
│   ├── conversion.py    # Pydantic models for API requests/responses
│   └── database.py      # SQLAlchemy ORM models
└── middleware/
    ├── metrics.py       # Prometheus metrics collection
    └── logging.py       # Request logging middleware

load_tester/
├── main.py              # Load tester FastAPI application
├── config.py            # Load tester configuration
├── logging_config.py    # Logging setup for load tester
├── models/              # Load test configuration and result models
│   ├── load_test.py     # Load test configuration models
│   ├── reports.py       # Test result and reporting models
│   └── scenarios.py     # Test scenario definitions
├── services/            # Load testing business logic
│   ├── currency_patterns.py      # Currency pair testing patterns
│   ├── load_generator.py         # Load generation engine
│   └── load_test_manager.py      # Test execution management
├── routers/             # Load test API endpoints
│   └── control.py       # Load test control endpoints
└── middleware/
    ├── metrics.py       # Load tester metrics collection
    └── logging.py       # Load tester logging

dashboard/
└── app.py               # Streamlit dashboard application

docker/                  # Docker configuration files
├── grafana/             # Grafana provisioning and dashboards
├── loki/                # Loki logging configuration
├── prometheus.yml       # Prometheus scraping configuration
└── promtail/            # Promtail log shipping configuration
```

### Key Architectural Patterns

**Configuration Management**: Uses Pydantic Settings with environment-based configuration
and validation. Settings automatically adapt between Docker and local environments.

**Database Layer**: SQLAlchemy with dependency injection pattern. Database sessions are
managed via FastAPI dependencies (`get_db()`). Test isolation uses separate test databases.

**Service Layer**: Business logic separated into dedicated services with clear interfaces
and comprehensive error handling for both currency operations and load testing.

**Observability Stack**: Complete observability with Prometheus metrics, Grafana dashboards,
Jaeger distributed tracing, and structured logging. All services instrumented with OpenTelemetry.

**Testing Strategy**: 228+ tests with database isolation. Each test suite uses separate
test databases in `tests/currency_app/databases/`. Integration tests override database dependencies.

### Database Models

**Key Tables**:

- `conversions`: Currency conversion transactions with full audit trail
- `exchange_rates`: Current exchange rates (10 supported currencies)
- `historical_rates`: Time-series data for 30+ days of rate history

**Important**: USD is the base currency (always 1.0). All rates are relative to USD.

### Docker Architecture

**Multi-stage Build**: Single Dockerfile with separate stages for API, Dashboard, and Load Tester services.
**Service Orchestration**: docker-compose.yml with persistent volumes, health checks, and
complete monitoring stack (Prometheus + Grafana + Jaeger) included by default.
**Observability Stack**: All services start together with full observability - no optional profiles needed.

## Test Structure and Patterns

### Test Organization

```text
tests/
├── currency_app/
│   ├── test_api.py                      # Integration tests for all endpoints
│   ├── test_currency_service.py         # Unit tests for core business logic
│   ├── test_rates_history_service.py    # Historical data service tests
│   ├── test_models.py                   # Pydantic model validation tests
│   ├── test_database.py                 # Database connection and migration tests
│   ├── test_metrics_endpoint.py         # Metrics endpoint tests
│   ├── test_metrics_integration.py      # Metrics integration tests
│   ├── test_metrics_middleware.py       # Prometheus middleware tests
│   ├── test_metrics_utilities.py        # Metrics utilities tests
│   └── databases/                       # Isolated test databases
├── load_tester/
│   ├── test_currency_patterns.py        # Currency pattern tests
│   ├── test_load_generator.py           # Load generation tests
│   ├── test_load_ramping.py             # Load ramping tests
│   ├── test_load_test_manager.py        # Load test management tests
│   ├── test_load_tester_api.py          # Load tester API tests
│   ├── test_ramping_api.py              # Ramping API tests
│   ├── test_reports.py                  # Report generation tests
│   ├── test_scenario_*.py               # Scenario-related tests (multiple files)
│   └── test_scenarios_api.py            # Scenarios API tests
└── dashboard/
    └── (future dashboard tests)
```

### Test Database Isolation

Each test file uses its own test database to prevent interference:

```python
# Pattern used in integration tests
test_db_path = test_db_dir / "test_specific_name.db"
test_engine = create_engine(f"sqlite:///{test_db_path}")
```

**Important**: Always clean up database dependency overrides in test teardown to prevent
test pollution between different test suites.

### Prometheus Metrics Testing

When testing Prometheus Counter metrics, they create both `_total` and `_created` samples:

```python
# Correct pattern for testing Counter metrics
samples = list(counter.collect())[0].samples
total_samples = [s for s in samples if s.name.endswith('_total')]
assert len(total_samples) > 0
```

## Available Services and URLs

When running with `make` (Docker), these services are available:

- **Currency API**: <http://localhost:8000> (FastAPI with interactive docs at /docs)
- **Streamlit Dashboard**: <http://localhost:8501> (Interactive web interface)
- **Load Tester API**: <http://localhost:8001> (Load testing service with docs at /docs)
- **PostgreSQL Database**: localhost:5432 (Database server - currency_user/currency_pass)
- **Prometheus**: <http://localhost:9090> (Metrics collection and querying)
- **Grafana**: <http://localhost:3000> (Dashboards and alerting - login: admin/admin)
- **Jaeger**: <http://localhost:16686> (Distributed tracing UI)

## PagerDuty Alerting

The system includes comprehensive alerting integration with PagerDuty:

- **Critical Alerts**: API down, high error rates, database issues
- **Warning Alerts**: High latency, high traffic, load test failures
- **Automated Notifications**: Real-time incident creation and resolution
- **Setup Guide**: See `docs/PAGERDUTY_SETUP.md` for complete configuration

**Quick Setup**:

1. Copy `.env.example` to `.env`
2. Set your `PAGERDUTY_CURRENCY_APP_KEY` in `.env`
3. Run `make rebuild` to restart with alerting enabled
4. Test integration: `set -a && source .env && set +a && poetry run python scripts/test_pagerduty.py`

## Distributed Tracing

The system includes comprehensive distributed tracing with OpenTelemetry and Jaeger:

### Tracing Features

- **End-to-End Request Tracing**: Track requests across currency API, load tester, and dashboard
- **Business Logic Spans**: Detailed spans for currency conversions, rate lookups, validations
- **Database Query Tracing**: Automatic SQLAlchemy instrumentation for all database operations
- **HTTP Request Tracing**: FastAPI auto-instrumentation for all HTTP endpoints and external requests
- **Cross-Service Correlation**: Trace propagation between currency API and load tester services
- **Error Context**: Rich error information with trace correlation and business context

### Using Traces

Access Jaeger UI at <http://localhost:16686> when running with Docker to:

1. **Service Selection**: Choose `currency-api` or `load-tester` services
2. **Operation Filtering**: Filter by specific endpoints like `/api/v1/convert` or `/api/v1/rates`
3. **Tag Search**: Search by currency pairs, amounts, or error types
4. **Performance Analysis**: View request timing, database query performance, and bottlenecks

## Configuration and Environment

**Local Development**: Uses PostgreSQL database (or SQLite for testing), default ports
(8000 for API, 8501 for dashboard)
**Docker Deployment**: Includes PostgreSQL service, environment variables override defaults,
services communicate via internal networking (`api:8000` for dashboard to API communication,
`postgres:5432` for database)

**Key Environment Variables**:

- `DATABASE_URL`: Database connection string (PostgreSQL for Docker, SQLite for local testing)
- `API_BASE_URL`: Dashboard API endpoint (defaults to localhost for local, api:8000 for Docker)
- `JAEGER_ENDPOINT`: OpenTelemetry collector endpoint for tracing
- `OTEL_SERVICE_NAME`: Service name for distributed tracing

**PostgreSQL Configuration (Docker)**:

- Database: `currency_db`
- Username: `currency_user`
- Password: `currency_pass`
- Port: `5432` (internal), exposed on `localhost:5432`

## Development Best Practices in Codebase

**Type Safety**: Comprehensive type annotations with pyright type checking enabled
**Error Handling**: Custom exceptions (`InvalidCurrencyError`), structured error responses
**Financial Precision**: Uses `Decimal` type with banker's rounding (`ROUND_HALF_EVEN`)
**Request Validation**: Pydantic models validate all inputs with detailed error messages
**Observability**: Request tracing with UUIDs, comprehensive metrics, and distributed tracing
**Load Testing**: Built-in load testing service for performance validation

## Pre-commit Hooks

Configured hooks run automatically before each commit:

- **Ruff**: Code formatting and linting (Python files in `currency_app/`, `load_tester/`,
  `dashboard/`, `tests/`)
- **Pyright**: Type checking (Python files in `currency_app/`, `load_tester/`, `dashboard/`,
  `tests/`)
- **Markdownlint**: Markdown formatting (all `.md` files)
- **OpenAPI Generation**: Automatically generates `api_specs/openapi.json` when `currency_app/`
  Python files change
- **General**: Trailing whitespace, end-of-file-fixer, YAML/TOML validation

Setup: `pre-commit install` after `poetry install` (one-time)

## Code Style Requirements

- Use lowercase built-in types: `list`, `dict`, `set`, `tuple` (not `List`, `Dict`, etc.)
- Keep line length to 100 characters max
- Use Google-style docstrings for all functions and classes
- No trailing whitespace, files must end with newline
- Follow ruff rules configured in pyproject.toml
- Comprehensive type annotations required

## Important Notes for Development

**Database Sessions**: Always use dependency injection via `get_db()` for database access
**Database**: Production uses PostgreSQL, tests use isolated SQLite databases in `tests/*/databases/`
**Test Isolation**: Each test file uses separate SQLite databases for fast, isolated testing
**Metrics Testing**: Prometheus Counter metrics create both `_total` and `_created` samples
**Tracing**: All services instrumented with OpenTelemetry for request correlation
**Docker First**: Primary development workflow uses Docker containers with `make` commands
**Financial Data**: Always use `Decimal` types for currency amounts and exchange rates
**PostgreSQL**: Connection pooling configured with 10 base connections, 20 overflow connections
