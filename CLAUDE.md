# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a load testing and dashboard system designed to test external currency conversion services.
The system calls an external currency API to perform load testing and provide analytics. It includes:

- **Load Testing Service**: Performance testing with configurable scenarios for external APIs
- **Interactive Dashboard**: Streamlit web interface for testing and analytics
- **External Service Integration**: Calls external currency conversion API
- **Docker Deployment**: Containerized load testing setup

## Development Commands (Docker-First)

### Quick Start

```bash
# First, start the external currency service (from separate repo)
# Then start the load tester and dashboard:
make              # Show help with available commands (default)
make up           # Start load tester and dashboard services
make down         # Stop all services
make logs         # View service logs (Ctrl+C to exit)
```

### Docker Workflow

```bash
make rebuild                   # Rebuild containers and restart all services
make clean                     # Clean all Docker resources (images, volumes, containers)
make test                      # Run tests with coverage inside container
make quality                   # Run code quality checks (format, lint, type-check)
```

### Local Development (Alternative)

```bash
poetry install                                    # Install dependencies
# Currency API is deployed from external repository via Docker
poetry run streamlit run dashboard/app.py         # Start dashboard (separate terminal)
```

### Testing Commands

```bash
make test                                         # Full test suite with coverage (Docker)
poetry run pytest tests/ -v --cov=load_tester --cov=dashboard --cov-report=term-missing
poetry run pytest tests/load_tester/test_load_generator.py -v  # Run specific test file
poetry run pytest tests/dashboard/ -v                              # Run dashboard tests
poetry run pytest -k "test_convert" -v           # Run tests matching pattern
```

### Code Quality

```bash
make quality                                      # All quality checks (Docker)
poetry run ruff format load_tester/ dashboard/ tests/  # Format code
poetry run ruff check --fix load_tester/ dashboard/ tests/        # Lint code
poetry run pyright load_tester/ dashboard/ tests/            # Type checking
# OpenAPI spec generated by external currency API repository
```

## Architecture Overview

### Application Structure

```text
currency_app/
├── main.py              # FastAPI app with lifespan, middleware, and tracing setup
├── config.py            # Pydantic Settings for environment-based configuration
├── database.py          # SQLAlchemy engine, session management
├── tracing_config.py    # OpenTelemetry tracing configuration
├── logging_config.py    # Structured logging setup
├── routers/             # FastAPI route handlers
│   ├── conversion.py    # Currency conversion endpoints
│   ├── rates.py         # Current + historical rates endpoints
│   ├── health.py        # Health check endpoints
│   └── home.py          # API information endpoint
├── services/            # Business logic layer
│   ├── currency_service.py        # Core conversion logic with simulated rates
│   └── rates_history_service.py   # Historical data management
├── models/              # Data models
│   ├── conversion.py    # Pydantic models for API requests/responses
│   └── database.py      # SQLAlchemy ORM models
└── middleware/
    # Note: metrics.py removed - no monitoring in simplified system
    └── logging.py       # Request logging middleware

load_tester/
├── main.py              # Load tester FastAPI application
├── config.py            # Load tester configuration
├── logging_config.py    # Logging setup for load tester
├── models/              # Load test configuration and result models
│   ├── load_test.py     # Load test configuration models
│   ├── reports.py       # Test result and reporting models
│   └── scenarios.py     # Test scenario definitions
├── services/            # Load testing business logic
│   ├── currency_patterns.py      # Currency pair testing patterns
│   ├── load_generator.py         # Load generation engine
│   └── load_test_manager.py      # Test execution management
├── routers/             # Load test API endpoints
│   └── control.py       # Load test control endpoints
└── middleware/
    └── logging.py       # Load tester logging

dashboard/
└── app.py               # Streamlit dashboard application

# Note: docker/ directory removed - no monitoring configuration needed
```

### Key Architectural Patterns

**Configuration Management**: Uses Pydantic Settings with environment-based configuration
and validation. Settings automatically adapt between Docker and local environments.

**Database Layer**: SQLAlchemy with dependency injection pattern. Database sessions are
managed via FastAPI dependencies (`get_db()`). Test isolation uses separate test databases.

**Service Layer**: Business logic separated into dedicated services with clear interfaces
and comprehensive error handling for both currency operations and load testing.

**Logging**: File-based structured logging for load tester operations and debugging.

**Testing Strategy**: 228+ tests with database isolation. Each test suite uses separate
test databases in `tests/currency_app/databases/`. Integration tests override database dependencies.

### Database Models

**Key Tables**:

- `conversions`: Currency conversion transactions with full audit trail
- `exchange_rates`: Current exchange rates (10 supported currencies)
- `historical_rates`: Time-series data for 30+ days of rate history

**Important**: USD is the base currency (always 1.0). All rates are relative to USD.

### Docker Architecture

**Multi-stage Build**: Single Dockerfile with separate stages for API, Dashboard, and Load Tester services.
**Service Orchestration**: docker-compose.yml with persistent volumes, health checks, and
**Simplified Architecture**: Load tester and dashboard services only - no monitoring dependencies.

## Test Structure and Patterns

### Test Organization

```text
tests/
├── currency_app/
│   ├── test_api.py                      # Integration tests for all endpoints
│   ├── test_currency_service.py         # Unit tests for core business logic
│   ├── test_rates_history_service.py    # Historical data service tests
│   ├── test_models.py                   # Pydantic model validation tests
│   ├── test_database.py                 # Database connection and migration tests
# Note: Metrics tests removed - no monitoring in load_tester
│   └── databases/                       # Isolated test databases
├── load_tester/
│   ├── test_currency_patterns.py        # Currency pattern tests
│   ├── test_load_generator.py           # Load generation tests
│   ├── test_load_ramping.py             # Load ramping tests
│   ├── test_load_test_manager.py        # Load test management tests
│   ├── test_load_tester_api.py          # Load tester API tests
│   ├── test_ramping_api.py              # Ramping API tests
│   ├── test_reports.py                  # Report generation tests
│   ├── test_scenario_*.py               # Scenario-related tests (multiple files)
│   └── test_scenarios_api.py            # Scenarios API tests
└── dashboard/
    └── (future dashboard tests)
```

### Test Database Isolation

Each test file uses its own test database to prevent interference:

```python
# Pattern used in integration tests
test_db_path = test_db_dir / "test_specific_name.db"
test_engine = create_engine(f"sqlite:///{test_db_path}")
```

**Important**: Always clean up database dependency overrides in test teardown to prevent
test pollution between different test suites.

### Load Testing Patterns

Load tests use configurable scenarios and patterns for comprehensive API testing.

## Available Services and URLs

When running with `make up`, these load testing services are available:

- **Streamlit Dashboard**: <http://localhost:8501> (Load testing interface and analytics)
- **Load Tester API**: <http://localhost:8001> (Load testing service with docs at /docs)

**External Service Dependencies**:

- **Currency API**: <http://localhost:8000> (External currency service - must be running separately)

**Note**: The load tester calls the external currency API running at `localhost:8000`. Ensure the
external currency service is started before running the load tester.

## External Currency Service Setup

This load testing system requires an external currency conversion API to test against.

**Prerequisites**:

1. Start the external currency service on `localhost:8000`
2. Ensure the currency service is healthy and responding
3. The load tester will automatically discover and test available endpoints

**Service Communication**:

- Load tester calls external API at `http://localhost:8000` (or configured endpoint)
- Dashboard displays metrics from both load tester and external service responses
- No database or monitoring dependencies - external service handles its own observability

## Load Testing Features

The load testing system provides comprehensive testing capabilities:

### Testing Capabilities

- **Configurable Load Patterns**: Variable request rates, burst testing, and sustained load
- **Currency Conversion Testing**: Automated testing of currency conversion endpoints
- **Rate Lookup Testing**: Performance testing of exchange rate retrieval
- **Multi-scenario Testing**: Support for different testing scenarios and patterns
- **Real-time Metrics**: Live performance monitoring and response time tracking
- **Error Analysis**: Detailed error tracking and failure analysis

### Using the Load Tester

Access the Load Tester API at <http://localhost:8001> to:

1. **Configure Tests**: Set up load testing scenarios via API endpoints
2. **Monitor Progress**: Real-time monitoring of test execution and metrics
3. **View Results**: Comprehensive test reports and performance analytics
4. **Performance Analysis**: View request timing, database query performance, and bottlenecks

## Configuration and Environment

**Local Development**: Uses PostgreSQL database (or SQLite for testing), default ports
(8000 for API, 8501 for dashboard)
**Docker Deployment**: Includes PostgreSQL service, environment variables override defaults,
services communicate via internal networking (`api:8000` for dashboard to API communication,
`postgres:5432` for database)

**Key Environment Variables**:

- `DATABASE_URL`: Database connection string (PostgreSQL for Docker, SQLite for local testing)
- `API_BASE_URL`: Dashboard API endpoint (defaults to localhost for local, api:8000 for Docker)
- `LOAD_TESTER_LOG_FILE`: File path for load tester logging
- `JWT_SECRET_KEY`: Secret key for load tester JWT authentication

## Development Best Practices in Codebase

**Type Safety**: Comprehensive type annotations with pyright type checking enabled
**Error Handling**: Custom exceptions (`InvalidCurrencyError`), structured error responses
**Financial Precision**: Uses `Decimal` type with banker's rounding (`ROUND_HALF_EVEN`)
**Request Validation**: Pydantic models validate all inputs with detailed error messages
**Logging**: File-based structured logging with request correlation
**Load Testing**: Built-in load testing service for performance validation

## Pre-commit Hooks

Configured hooks run automatically before each commit:

- **Ruff**: Code formatting and linting (Python files in `currency_app/`, `load_tester/`,
  `dashboard/`, `tests/`)
- **Pyright**: Type checking (Python files in `currency_app/`, `load_tester/`, `dashboard/`,
  `tests/`)
- **Markdownlint**: Markdown formatting (all `.md` files)
- **OpenAPI Generation**: Automatically generates `api_specs/openapi.json` when `currency_app/`
  Python files change
- **General**: Trailing whitespace, end-of-file-fixer, YAML/TOML validation

Setup: `pre-commit install` after `poetry install` (one-time)

## Code Style Requirements

- Use lowercase built-in types: `list`, `dict`, `set`, `tuple` (not `List`, `Dict`, etc.)
- Keep line length to 100 characters max
- Use Google-style docstrings for all functions and classes
- No trailing whitespace, files must end with newline
- Follow ruff rules configured in pyproject.toml
- Comprehensive type annotations required

## Important Notes for Development

**Database Sessions**: Always use dependency injection via `get_db()` for database access
**Database**: Production uses PostgreSQL, tests use isolated SQLite databases in `tests/*/databases/`
**Test Isolation**: Each test file uses separate SQLite databases for fast, isolated testing
**Load Testing**: Focus on external API testing with configurable scenarios
**Docker First**: Primary development workflow uses Docker containers with `make` commands
**Financial Data**: Always use `Decimal` types for currency amounts and exchange rates
**PostgreSQL**: Connection pooling configured with 10 base connections, 20 overflow connections
